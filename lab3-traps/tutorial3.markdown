# MIPS Lab 3 HOWTO - A Step by Step (??) Walkthrough

## Overview

Lab 3 comprises of only one task: exception handling.

Moreover, we're going to treat these exceptions specially:

1. Interrupts
    - Clock interrupts
    - Interprocessor interrupts (IPI)
    - Peripheral device interrupts
2. System calls
    - We're not implementing actual system calls; we're dealing with the
      mechanism for handling system calls
3. (Optional) Breakpoints and Trap instructions, for debugging

## Before we do that...

We'll have to figure out how to measure time interval first.

On x86 or x86-64 systems, this is usually done by some *high precision event
timer* (HPET), or on older systems, *real time clock* (RTC) or *programmable
interval timer* (PIT), via some PCI access instructions or more modern `RDTSC`
instruction.

On MIPS, each processor carries a `COUNT` coprocessor register, which relates
to pipeline clock of the processor, thus increases at a constant rate.

To delay or sleep for microseconds (such as `usleep(3)`), it would be easy with
a microsecond-precision RTC.  However, there's only a second-precision RTC
on Loongson boxes, and one is only able to achieve microsecond-precision by
measuring the relation between `COUNT` increment rate and that of RTC.
So one should take possible capabilities on different
machines into consideration when designing framework for clock devices.

### `<asm/mipsregs.h>`

In C code, you can conveniently read or write to coprocessor registers
by something like

```C
#include <asm/mipsregs.h>

uint32_t count = read_c0_count();
```

or

```C
#include <asm/mipsregs.h>

write_c0_status(status);
```

### MSIM RTC

Actually, MSIM RTC contains two registers, as opposed to the documentation.

Denoting the base address of MSIM RTC `MSIM_RTC_BASE`:

- `MSIM_RTC_BASE + 0x0`: Seconds since epoch (1970/01/01 00:00:00)
- `MSIM_RTC_BASE + 0x4`: Microseconds

##### Programming exercise

1. Design a clock driver framework.  Think of primitives which should be
  supported by all clock devices, and the workaround if some device can't
  support your primitives.
    - There's no right answer, only reasonable answers.  You can do it
      however you like.
2. Measure the relation between `COUNT` increment rate and RTC clock, i.e.
  how much would `COUNT` increase by one second.
3. Implement two functions, `sleep(n)` and `usleep(n)`, to delay the processor
  for `n` seconds and `n` microseconds, respectively.  Your solution should be
  as precise as possible.
    - It's allowed to implement both functions using only RTC.  But it's not
      advised to skip the previous two tasks since `COUNT` is responsible to
      generate timer interrupts.

## How exceptions/interrupts work on x86

The relations between exceptions, traps, and interrupts differ between
architectures.  On x86, exceptions are treated as software interrupts, but on
MIPS, interrupts are treated as a special kind of exception instead.

Intel x86 architecture specified up to 256 possible interrupts, either hardware
ones or software ones.  Intel reserved the first 20 interrupts as processor
traps, which could only be generated by the processors (see `traps.h` in xv6).

For historical reasons, Intel x86 architectures use something called
*interrupt descriptor table* (IDT) to control the interrupts in a fine-grained
manner.  The entry in an IDT contains the interrupt number, interrupt type,
handler entry, descriptor (or interrupt invocation) privilege level,
code segment selector (which is related to execution privilege level), etc.
The data structure and code is thus quite obscure.

##### Paper exercise

Skim `trap.c`, `trapasm.S` and `vectors.S` in xv6 source code, to have a
rough image about how xv6 on x86 handles exceptions.

You probably have to `make(1)` it once first, to generate `vectors.S`.

## How exceptions work on MIPS

The mechanism in MIPS is very similar to, albeit much simpler than, the one on
x86.

Modern MIPS processors usually support vectored interrupts, where each
kind of interrupt has its own entry point, somewhat resembling x86.
However, we probably won't need it when writing an operating system
for general computers.  Even on x86 architectures, each separate interrupt
handler is finally routed into a common interrupt handler.

### Classic exception handling

#### Exception types

MIPS processors support up to 32 preset hardware exceptions:

|Code|Name                |C Macro        |Details                            |
|:---|:-------------------|:--------------|:----------------------------------|
|0   |Interrupt           |`EC_int`       |Can be either software or hardware |
|1   |TLB modification    |`EC_tlbm`      |Writing to a read-only page        |
|2   |TLB load miss       |`EC_tlbl`      |Reading invalid/non-existent page  |
|3   |TLB store miss      |`EC_tlbs`      |Writing invalid/non-existent page  |
|4   |Address error (load)|`EC_adel`      |Usually mean an erroneous program  |
|5   |Address error(store)|`EC_ades`      |Usually mean an erroneous program  |
|6   |Bus error (load)    |`EC_ibe`       |Bus error on load, rare            |
|7   |Bus error (store)   |`EC_dbe`       |Bus error on store, rare           |
|8   |System call         |`EC_sys`       |System call                        |
|9   |Breakpoint          |`EC_bp`        |When executing `break` instruction |

|10  |Reserved intruction |`EC_ri`        |Usually an illegal instruction     |
|11  |Coprocessor Unusable|`EC_cpu`       |E.g. accessing CP0 in user mode    |
|12  |Arithmetic overflow |`EC_ov`        |Rarely used                        |
|13  |Trap                |`EC_tr`        |If trapping conditions are met     |
|14  |-                   |-              |-                                  |
|15  |Floating point      |`EC_fpe`       |Divide by zero, etc.               |
|16  |-                   |-              |-                                  |
|..  |-                   |-              |-                                  |
|29  |-                   |-              |-                                  |
|30  |Cache error         |`EC_cacheerr`  |Cache error, rare                  |
|31  |-                   |-              |-                                  |

#### MIPS Exception vector

*Exception vectors* are lists of exception handler entry points.  ARM, MIPS and
other RISC CPUs all have exception vectors, and x86 architecture specify
exception vectors through the interrupt descriptor table.

The exception vector on MIPS is very simple.  Denoting the *exception vector
base address* `EBase`, MIPS specification defines the vector layout to be:

|Entry point      |Purpose                                                    |
|:----------------|:----------------------------------------------------------|
|`EBase + 0x000`  |TLB refill (TLB load/store miss) when `EXL = 0`            |
|`EBase + 0x080`  |XTLB refill (64-bit equivalent of TLB refill) if `EXL = 0` |
|`EBase + 0x100`  |Cache error                                                |
|`EBase + 0x180`  |Other cases                                                |

We would talk about TLB refills in later labs, since we're not dealing with
them here.  Cache error rarely happen as well, so the only exception handler
entry point we'll play with is the last one.

The value of `EBase` is determined by the `BEV` bit in `STATUS` register.
    - If `BEV` is set, `EBase = 0xbfc00200`.
    - If `BEV` is not set, `EBase = 0x80000000`.

The reasons why MIPS specification maintains *two* exception vectors are

1. Exceptions may happen at the very start of system bootstrap, e.g. before
  RAM and caches are initialized.  Therefore, a separate set of exception
  vectors residing in the ROM must be maintained, hence the `0xbfc00200`
  exception vector base.
2. The operating system kernel apparently has its own idea of how to
  deal with exceptions after being brought up, and therefore, another
  separate set should be maintained in RAM, with the physical
  address as small as possible, since we can't make assumptions about the
  RAM size, hence the `0x80000000` base.

#### Caution: kernel load address conflicts

We can see that addresses directly following `0x80000000` is reserved for
exception handlers.

Therefore, the first thing we should check is the load address of the kernel.
If you specified the kernel's load address to be `0x80000000` or somewhere
very close, then you'll be in trouble, since the processor will jump to
the start/middle of your kernel in case of an exception, wreaking havoc
in your system.

##### Programming exercise

Modify the linker script of your kernel and change the starting virtual
adress of your kernel, reserving some space for the exception handlers:

```ld
SECTIONS {
        . = <new-address>;
}
```

### Hardware actions in case of exceptions

When an exception is thrown, either because of program error, external
interrupts, etc., the processor

- Sets the `EXL` bit in `STATUS` register.
- Sets the `EPC` register to contain the address of the instruction
  where the exception is thrown, so that the processor can continue
  execution from where it had left.
    - When the exception happens at an instruction inside branch delay slot,
      `EPC` points to the branching instruction preceding it.  You can still
      return to `EPC` to continue execution, though, because branching
      instructions in MIPS never make changes to general purpose registers
      or coprocessor registers.
    - Everything before `EPC` look as if they were fully executed.
    - Instructions at or after `EPC` look as if they were never started.
    - Note that the `EPC` register won't be set if `EXL` is set.
- Jumps to the entry point defined above according to the exception type.

#### Branch delay slot?

In short, the instruction directly succeeding a branching instruction is
*always* executed, no matter whether the branch would take place or not.
The branch is then taken *after executing the instruction following the
branching instruction*.

Therefore, the instruction directly following a branching instruction is
called to be inside a *branch delay slot*.

Although when *writing* assemblies, one don't need to care the branch
delay thing, he should be aware of branch delays when dealing with
programs in instruction level, e.g. handling exceptions, reading
or processing disassemblies, etc.

The reason why branch delays happen is related to MIPS pipeline design,
which is available in the *See MIPS Run* book.

## How to handle exceptions

In case of a general exception (corresponding to "Other cases" in table
above), the kernel should do the following:

1. Allocate a structure and store all the important registers for trap
  handling.  Such structure is usually called a *trap frame*.
    - The layout of the structure is defined in `struct trapframe`,
      inside `stackframe.h`
2. Do everything in the general handler written in C.
3. After returning from C code, restore all the registers and execute
  the architecture-specific return-from-exception instruction.  On
  MIPS, this is the `eret` instruction.

### `stackframe.h`

Implementing the register saving/restoring process is quite time-consuming,
so we provided a header named `stackframe.h`, containing several macros
and definition of trap frame structure.

#### The content of trap frame

A trap frame in MIPS comprises of

1. All general purpose registers,
2. `EPC` register, because sometimes we want to return from exception to
  elsewhere (see Handling System Calls section),
3. `STATUS` and `CAUSE` registers,
4. Coprocessor registers related to memory management such as `ENTRYLO0`,
  `ENTRYLO1`, `ENTRYHI`, `BADVADDR`, etc.
5. `HI` and `LO` registers for multiplier/divider component.

The structure is defined in `struct trapframe` structure:

```C
struct trapframe {
        /* General Purpose Registers 
         * NOTE: Normally k0 and k1 need not be saved. */
        unsigned long gpr[32];
        /* Special registers LO/HI */
        unsigned long lo, hi;
        /* Necessary CP0 Registers */
        unsigned long cp0_status;
        unsigned long cp0_cause;
        unsigned long cp0_badvaddr;
        unsigned long cp0_epc;
        unsigned long cp0_entryhi;
};
```

The reason we choose `unsigned long` is that we should take care of both
MIPS32 and MIPS64 architectures.  The size of `long`s would be 32 bits
on 32-bit architectures, or 64 bits on 64-bit architectures.

#### `kernelsp`

Apparently, trap frames should be allocated in kernel stack rather than
user program stack, since the processors almost always switch to kernel
mode in case of an exception, and we don't want to dive into user
stack again just for allocating a trap frame.

We'll have to keep track of the kernel stack pointer in case of a
user program is interrupted by an exception by saving `sp` elsewhere
before moving to user mode.

The place for storing the kernel stack pointer is the array `kernelsp`,
which is a global variable.  This variable is MIPS-specific.

The macro for saving the kernel stack pointer is called `set_saved_sp`.

The one for getting (not restoring) the kernel stack pointer is
`get_saved_sp`.

#### Multiple kernel stacks for each CPU

As each CPU have its own kernel stack, the kernel stack pointer should
be retrieved by indexing the array with its own CPU ID.

#### `SAVE_ALL`

`SAVE_ALL` assembler macro does the following sequentially:

1. Get kernel stack pointer if we're transferring from user mode to kernel
  mode.
2. Allocate a trap frame from the kernel stack.
3. Store every register defined in the structure to the trap frame.

The address of the trap frame structure is thus stored at register `sp`.

#### `RESTORE_ALL_AND_RET`

`RESTORE_ALL_AND_RET` assembler macro restores all registers from
trap frame starting at `sp`, frees the trap frame from kernel stack, and
executes `eret`.

##### Programming exercise

Implement a trap handler, which

1. Saves all important registers, including but not limited to, all GPRs,
  multiplicator registers `LO` and `HI`,
  `STATUS`, `CAUSE`, `EPC`, `BADVADDR`, `ENTRYLO0`, `ENTRYLO1`, `ENTRYHI`
  (the last three are useful in later labs)
    - We save `STATUS`, `CAUSE`, `EPC` registers because we probably need
      to change their contents.
2. Ensure the processor runs in normal (no exception, no error), kernel mode,
  without interrupts.
3. Store the pointer to the trap frame to register `a0`.
4. Jump to C trap handler entry:
```C
void handle_exception(struct trapframe *tf)
```
  (or something like that)
5. Dump the trap frame contents and jump to an endless loop.
6. Restore the trap frame back to registers.
    - This step would be useful later.
7. `eret` to return from exception.

## Not finished

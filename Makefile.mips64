# Copyright (C) 2015 Gan Quan <coin2028@hotmail.com>
#
# This program is free software; you can redistribute  it and/or modify it
# under  the terms of  the GNU General  Public License as published by the
# Free Software Foundation;  either version 2 of the  License, or (at your
# option) any later version.

# Makefile for MIPS64

######## BEGIN CONFIG ########

# Cross-platform toolchain prefix.
# E.g. if
# 	CROSS_COMPILE = mips64-linux-gnu-
# then the cross-compiler should be
# 	mips64-linux-gnu-gcc
# The linker should be
# 	mips64-linux-gnu-ld
# etc.
CROSS_COMPILE	=  mips64-linux-gnu-

# Machine name.
MACH		=  loongson3a

# Target device for kernel & bootloader installation.
# 
# IMPORTANT:
# Make sure you select the correct device, or your own hard disk may become
# corrupted!
# I hadn't write the backup mechanism for kernel installation yet, but one
# can recover MBR in case of accidents.  Refer to boot/Makefile.mips64 for
# more information.
INSTALLDEV	=  /dev/sdb

CCOMPILER	=  gcc

# Only needed if the installation needs sudo privileges
SUDO		=  sudo

# The partition number.  DO NOT CHANGE THIS.
PARTNO		=  2
########  END  CONFIG ########

# Retrieve root directory.
# The expression $(shell <command>) executes the shell command and returns
# the output.
ROOTDIR		=  $(shell pwd)

# Capitalize $MACH, this is to be used for defining machine-specific
# macro MACH_$(UPPERMACH).
# E.g. if
# 	MACH = loongson3a
# then gcc compiles source code with
# 	MACH_LOONGSON3A
# defined.
UPPERMACH	=  $(shell echo $(MACH) | tr a-z- A-Z_)

# Cross-platform versions of GNU toolchain
CC		=  $(CROSS_COMPILE)$(CCOMPILER)
CPP		=  $(CROSS_COMPILE)cpp
LD		=  $(CROSS_COMPILE)ld
OBJCOPY		=  $(CROSS_COMPILE)objcopy
OBJDUMP		=  $(CROSS_COMPILE)objdump

# Specify all absolute include path, prepending each with -I (the include
# directory flag for gcc)
INCFLAG		=  -I$(ROOTDIR) -I$(ROOTDIR)/include
INCFLAG		+= -I$(ROOTDIR)/include/arch/$(ARCH)

# Compiling flags for GCC, see gcc(1) for details of each option.
CFLAGS		=  -O2 -G 0 -mno-abicalls -fno-pic -Wall -mabi=64 -fno-builtin
CFLAGS		+= -nostdinc -nostdlib -g -mips64r2 -EL $(INCFLAG)
CFLAGS		+= -DMACH_$(UPPERMACH)

# Linker script for ld(1)
LDSCRIPT	=  kern/arch/$(ARCH)/ldscript.ld
# Linker flag for ld(1)
LDFLAGS		=  -EL -N

# All object files
OBJS		=  kern/arch/$(ARCH)/start.o \
		   kern/init/stub.o \
		   drivers/serial/uart16550.o \
		   drivers/serial/uart.o \
		   drivers/serial/uart-printf.o \
		   lib/libc/stdio/snprintf.o \
		   lib/libc/string/memset.o

# Final program
BINARY		=  bootstrap
# Disassembly
DISASSEMBLY	=  $(BINARY).s

# Export all variables above to child make processes, which will
# spawn when compiling bootloader and userspace programs
export

# all: the default target when no target is specified in command
# line.
#
# Makes kernel and bootloader.
all: elf boot

# elf: Make kernel by linking the object files and disassembling
# the binary program after all object files are compiled.
elf: $(OBJS)
	$(LD) $(LDFLAGS) -T $(LDSCRIPT) -o $(BINARY) $(OBJS)
	$(OBJDUMP) -S $(BINARY) >$(DISASSEMBLY)

# boot: Make bootloader.
# Change into boot/ directory and build there.
boot:
	cd boot && make -f Makefile.$(ARCH)

# install: Perform kernel and bootloader installation.
#
# First install bootloader by changing into boot/ directory and
# perform bootloader installation, then invoke the kernel installation
# perl script.
install: all
	cd boot && make -f Makefile.$(ARCH) install
	$(SUDO) ./tools/arch/$(ARCH)/$(MACH)/install-kernel.pl \
		$(INSTALLDEV) $(BINARY) $(PARTNO)

# clean: Remove all files generated by make.
clean:
	cd boot && make -f Makefile.$(ARCH) clean
	rm -rf $(OBJS) $(BINARY)

# make by default doesn't know how to compile assemblies.  So we specify
# the procedure here.
.S.o:
	$(CC) $(CFLAGS) -c $< -o $*.o
